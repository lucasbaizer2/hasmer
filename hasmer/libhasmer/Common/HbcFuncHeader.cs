using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.IO;

namespace Hasmer {
    /// <summary>
    /// The flags a function can have. Note that the Prohibit* flags cannot be used in conjunction with Enum.HasFlag because ProhibitCall is 0.
    /// </summary>
    public enum HbcFuncHeaderFlags : byte {
        ProhibitCall = 0x00,
        ProhibitConstruct = 0x01,
        ProhibitNone = 0x02,
        StrictMode = 0x04,
        HasExceptionHandler = 0x08,
        HasDebugInfo = 0x10,
        Overflowed = 0x20
    }

    /// <summary>
    /// Represents a function header definition in a Hermes bytecode file.
    /// </summary>
    public class HbcFuncHeader : HbcEncodedItem {
        /// <summary>
        /// The sequential ID of the function.
        /// </summary>
        public uint FunctionId { get; set; }

        /// <summary>
        /// The offset in the HbcFile of the function.
        /// </summary>
        public uint Offset { get; set; }

        /// <summary>
        /// The amount of parameters that the function takes.
        /// </summary>
        public uint ParamCount { get; set; }

        /// <summary>
        /// The amount of bytes that the function's bytecode takes up.
        /// </summary>
        public uint BytecodeSizeInBytes { get; set; }

        /// <summary>
        /// The index in the string table of the function's name (i.e. HbcFile.GetStringTableEntry(FunctionName)).
        /// </summary>
        public uint FunctionName { get; set; }

        /// <summary>
        /// The offset in the HbcFile of additional (i.e. debug) information about the function.
        /// </summary>
        public uint InfoOffset { get; set; }

        /// <summary>
        /// The amount of registers that the function has.
        /// </summary>
        public uint FrameSize { get; set; }

        /// <summary>
        /// The amount of symbols that the function has.
        /// </summary>
        public uint EnvironmentSize { get; set; }

        public uint HighestReadCacheIndex { get; set; }

        public uint HighestWriteCacheIndex { get; set; }

        /// <summary>
        /// The flags of the function.
        /// </summary>
        public HbcFuncHeaderFlags Flags { get; set; }

        [JsonIgnore]
        public HbcFile DeclarationFile { get; set; }

        /// <summary>
        /// The disassembled instructions of the function cached by a call to <see cref="HbcFuncHeader.Disassemble"/>.
        /// </summary>
        private List<HbcInstruction> CachedInstructions { get; set; }

        /// <summary>
        /// Gets the header that should be used for disassembly and decompilation, i.e. the header that contains instructions.
        /// <see cref="HbcSmallFuncHeader"/> objects do not contain bodies, so this returns the large header for such objects.
        /// </summary>
        public virtual HbcFuncHeader GetAssemblerHeader() {
            return this;
        }

        /// <summary>
        /// Gets the name of a function, or the autogenerated name of a closure if it's an unnamed closure.
        /// </summary>
        public string GetFunctionName(HbcFile source) {
            HbcSmallFuncHeader func = source.SmallFuncHeaders[FunctionId];
            string functionName = source.GetStringTableEntry((int)func.FunctionName).Value;
            if (functionName == "") {
                return $"$closure${FunctionId}";
            }
            functionName = functionName.Replace(">", "\\>");
            return functionName;
        }

        /// <summary>
        /// Clears the instructions cache so that a future call to <see cref="Disassemble"/> will disassemble and re-cache the data from scratch.
        /// </summary>
        public void ClearInstructionCache() {
            CachedInstructions = null;
        }

        /// <summary>
        /// Disassembles the function, parsing the bytecode into an <see cref="HbcInstruction">HbcInstruction</see> object for each instruction.
        /// <br />
        /// The instructions will be cached. To clear the cache and have this function re-parse the instructions, see <see cref="ClearInstructionCache"/>.
        /// </summary>
        public List<HbcInstruction> Disassemble() {
            if (CachedInstructions != null) {
                return CachedInstructions;
            }

            CachedInstructions = new List<HbcInstruction>();
            uint offset = GetAssemblerHeader().Offset - DeclarationFile.InstructionOffset;

            using MemoryStream ms = new MemoryStream(DeclarationFile.Instructions);
            ms.Position = offset;

            uint instructionOffset = 0;
            using BinaryReader reader = new BinaryReader(ms);
            while (ms.Position < offset + BytecodeSizeInBytes) {
                long startPos = ms.Position;
                byte opcodeValue = reader.ReadByte();
                HbcInstructionDefinition def = DeclarationFile.BytecodeFormat.Definitions[opcodeValue];

                List<HbcInstructionOperand> operands = new List<HbcInstructionOperand>(def.OperandTypes.Count);
                foreach (HbcInstructionOperandType type in def.OperandTypes) {
                    operands.Add(HbcInstructionOperand.FromReader(reader, type));
                }

                long endPos = ms.Position;
                CachedInstructions.Add(new HbcInstruction {
                    Opcode = opcodeValue,
                    Operands = operands,
                    Offset = instructionOffset,
                    Length = (uint)(endPos - startPos)
                });

                instructionOffset += (uint)(endPos - startPos);
            }

            return CachedInstructions;
        }
    }
}
